<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>朱晨奕的博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-02-12T12:46:15.067Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>朱晨奕</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>springboot笔记（一）</title>
    <link href="http://example.com/2022/02/12/springboot%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://example.com/2022/02/12/springboot%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2022-02-11T18:31:24.000Z</published>
    <updated>2022-02-12T12:46:15.067Z</updated>
    
    <content type="html"><![CDATA[<p>1.maven的parent标签，一方面是引入了子项目必要的依赖，另一方面是用来做版本管理。例如spring-boot-dependencies.pom文件中已经声明了activemq,jdbc等依赖的版本，我们web应用中引入spring-boot-starter-web时就不需要再指定他们的版本了，他们将直接使用spring-boot-dependencies中的版本号。（继承关系为：spring-boot-dependencies → spring-boot-parent → spring-boot-starters → spring-boot-starter-web）<br><br/><br>2.springboot默认scan主程序MainApplication所在的package和子包<br><br/><br>3.@Configuration标签替代之前注册bean的xml文件，用@Bean注册组件（默认单例模式）<br><br/><br>4.proxyBeanMethods，代理模式，默认为true：<br>full:@Configuration(proxyBeanMethod=true)，全代理模式，组件为单例<br>lite:@Configutation(proxyBeanMethod=false)，轻量级代理模式，每次获取组件都会调用一次构造方法，非单例模式。好处是不用做单例检查，使应用启动更快。但由于每次都是重新构建实例，实例间将不存在依赖。<br><br/><br>5.@Import：注解提供了@Bean注解的功能，同时还有原来Spring基于 xml 配置文件里的<import>标签组织多个分散的xml文件的功能<br>@ConditionalXXX：有条件的注入组件<br>@ImportResource：导入beans.xml资源<br><br/><br>6.@ConfigurationProperties(prifix=“”)读取配置文件中的值，与@Value效果类似。标记后该类不会进入容器，需要用@Componet等注解注册到容器，或者在config类上使用@EnableConfigurationProperties进行注册（见下文）<br>@EnableConfigurationProperties(User.class)，与@ConfigurationProperties一同使用，标记在@Configuration的类中（即需要标记在config类中），开启User的读取配置功能，并且将User注入至容器</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.maven的parent标签，一方面是引入了子项目必要的依赖，另一方面是用来做版本管理。例如spring-boot-dependencies.pom文件中已经声明了activemq,jdbc等依赖的版本，我们web应用中引入spring-boot-starter-web</summary>
      
    
    
    
    
    <category term="spring" scheme="http://example.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>算法笔记（一）</title>
    <link href="http://example.com/2022/02/12/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://example.com/2022/02/12/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2022-02-11T18:31:14.000Z</published>
    <updated>2022-02-13T15:25:19.517Z</updated>
    
    <content type="html"><![CDATA[<p>1.在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下的顺序排序。请完成一个函数，输入这样的一个二维数字和整数，判断数组中是否含有该整数。（剑指offer P38）<br>思路：<br>1　　2　　8　　9<br>2　　4　　9　　12<br>4　　7　　10　　13<br>5　　8　　11　　15</p><p>这题阶梯关键是找准起点，类似的数组题第一反应都是先从a<sub>0</sub><sub>0</sub>开始，如图左上角1。但是从1开始的话会发现问题变得很复杂，每次移动都有向下向右两种选择，必然会有个别数经历了多次遍历，所以起点应该从右上/左下开始。以上图9为例，9是第一行最大的以及第四列最小的。若输入比9小则排除9下面的三个数字，查找9左边的三列，指针向左移动；同理，若输入比9大则指针向下移动。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">method</span><span class="hljs-params">(<span class="hljs-type">int</span> num, <span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>        <span class="hljs-keyword">if</span> (matrix == <span class="hljs-literal">null</span> || matrix.length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rows</span> <span class="hljs-operator">=</span> matrix.length; <span class="hljs-comment">//行数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">columns</span> <span class="hljs-operator">=</span> matrix[<span class="hljs-number">0</span>].length; <span class="hljs-comment">//列数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> columns - <span class="hljs-number">1</span>; <span class="hljs-comment">//横坐标。第一次做时这里少了-1，会导致指针越界</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//纵坐标</span><br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt;= rows - <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//注意边界，纵坐标从0开始到rows - 1</span><br>            <span class="hljs-keyword">if</span> (matrix[i][j] == num) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[i][j] &gt; num) &#123;<br>                i = i - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (matrix[i][j] &lt; num) &#123;<br>                j = j + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>2.请实现一个函数，把字符串中的每个空格替换成&quot;%20&quot;。例如输入&quot;we are happy&quot;，则输出&quot;we%20are%20happy&quot;。（剑指offer P44）</p><p>思路：这里题目有点没描述清楚，实际应该是没有额外的内存空间（即你不能再new一个字符串，否则这题就没意义了），而是在input数组后面留有额外的空间供你移动字符，即</p><p>input = &quot;we are happy\0             &quot;</p><p>如果从头开始遍历，后面的字符会移动多次影响效率。正确的思路是先遍历一遍找出空格的个数，将要扩充的空间提前留出来，再从后往前替换空格。</p><p>书中的最终代码把问题简化了，若是扩容后新字符串长度超过了input的最大长度，书中直接return了，下面的代码考虑了比较复杂的情况，即如果扩容后超过input.length了，则截断保留最大长度。</p><p>例如扩容后字符串为&quot;%20we%20are%20happy%20\0&quot;，共22个字符，而input.length = 20，则返回”&quot;%20we%20are%20happy%“（长度20）</p><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">char</span>[] method2(<span class="hljs-type">char</span>[] input) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> input.length;<br>        <span class="hljs-keyword">if</span> (length == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> input;<br>        &#125;<br>        <span class="hljs-comment">//找出空格的个数，以及字符串长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">strLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-keyword">if</span> (input[i] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                count++;<span class="hljs-comment">//空格数</span><br>            &#125;<br>            <span class="hljs-keyword">if</span> (input[i] == <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;<span class="hljs-comment">//字符串结束</span><br>                strLength = i + <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//&quot;%20&quot;比空格多两个字符，每有一个空格字符串总长都要+2</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">newStrLength</span> <span class="hljs-operator">=</span> strLength + <span class="hljs-number">2</span> * count;<br>        <span class="hljs-comment">//第一次做时漏了这个情况，即扩容后如果超出了input的总长要怎么处理</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (newStrLength &gt; length) &#123;<br>            diff = newStrLength - length;<br>        &#125;<br>        <span class="hljs-comment">//i是扩容前字符串游标，从末尾开始</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> strLength - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//j是扩容后字符串游标，从末尾开始</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> newStrLength - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//考虑扩容后超出input总长的情况：超出了diff个字符，就要在扩容后的字符中拿掉diff个字符</span><br>        <span class="hljs-comment">//则从input末尾开始往前删字符，删掉一个非空格等于删掉一个字符，删掉一个空格等于删掉3个字符</span><br>        <span class="hljs-keyword">if</span> (diff &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//如果扩容后长度超了，那j就从input的最后一位开始</span><br>            j = length - <span class="hljs-number">1</span>;<br>            <span class="hljs-comment">//k为待删除的字符数，删掉一个就-1</span><br>            <span class="hljs-type">int</span> k;<br>            <span class="hljs-keyword">for</span> (k = diff; k &gt; <span class="hljs-number">0</span>; ) &#123;<br>                <span class="hljs-keyword">if</span> (input[i] != <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                    i--;<br>                    k--;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    i--;<br>                    k = k - <span class="hljs-number">3</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//这里还存在一种情况，当0&lt;k&lt;3，就是还剩1或者2个字符要删，但是下一个要删的字符是空格，删掉一个空格等于删了3个，就是说多删了</span><br>            <span class="hljs-comment">//那就要把多删的补回来,多删了一个就在末尾补个&#x27;%&#x27;，多删了两个就再补个&#x27;2&#x27;</span><br>            <span class="hljs-keyword">if</span> (k &lt; <span class="hljs-number">0</span>) &#123;<br>                input[++i] = <span class="hljs-string">&#x27;%&#x27;</span>;<br>                k++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (k &lt; <span class="hljs-number">0</span>) &#123;<br>                input[++i] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (input[i] == <span class="hljs-string">&#x27; &#x27;</span>) &#123;<br>                input[j--] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                input[j--] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>                input[j--] = <span class="hljs-string">&#x27;%&#x27;</span>;<br>                i--;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                input[j--] = input[i--];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> input;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下的顺序排序。请完成一个函数，输入这样的一个二维数字和整数，判断数组中是否含有该整数。（剑指offer P38）&lt;br&gt;
思路：&lt;br&gt;
1　　2　　8　　9&lt;br&gt;
2　　4　　9　　12&lt;br&gt;</summary>
      
    
    
    
    
    <category term="算法" scheme="http://example.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
